# Паралелизация на Алгоритми за Търсене по Шаблон

**Български** | **[English](README.md)**

Високопроизводителна C# имплементация на паралелни алгоритми за търсене по шаблон с цялостен бенчмарк пакет.

## Общ Преглед

Този проект имплементира три класически алгоритма за търсене на шаблони в текст, както в последователна, така и в паралелна версия, демонстрирайки ползите от паралелизацията за изчислително интензивни задачи за обработка на текст.

## Имплементирани Алгоритми

### 1. Knuth-Morris-Pratt (KMP)
- **Времева Сложност**: O(n + m)
- **Предварителна Обработка**: Изчислява failure function за шаблона
- **Подход**: Линейно време за търсене използвайки префиксна информация
- **Най-добър за**: Общо предназначение

### 2. Boyer-Moore
- **Времева Сложност**: O(n/m) средно, O(nm) най-лош случай
- **Предварителна Обработка**: Изчислява таблица за лош символ
- **Подход**: Сканиране отдясно наляво с интелигентно прескачане
- **Най-добър за**: Големи азбуки и дълги шаблони

### 3. Aho-Corasick
- **Времева Сложност**: O(n + m + z), където z са съвпаденията
- **Предварителна Обработка**: Изгражда trie с failure връзки
- **Подход**: Краен автомат за търсене на множество шаблони
- **Най-добър за**: Търсене на множество шаблони едновременно

## Функционалности

- **Паралелни Имплементации**: Всички алгоритми включват оптимизирани паралелни версии
- **Бенчмарк на Производителността**: Детайлни метрики включващи:
  - Време за изпълнение (последователно срещу паралелно)
  - Коефициент на ускорение
  - Ефективност на нишките в проценти
  - Верификация на резултати
- **Генератор на Тестови Данни**: Конфигурируемо генериране на случаен текст
- **Интерактивно Меню**: Множество тестови сценарии
- **Мащабируемост на Нишките**: Автоматична или ръчна конфигурация на броя нишки

## Изисквания

- .NET 6.0 или по-нова версия
- Многоядрен процесор (препоръчително за паралелно тестване)

## Инсталация

```bash
# Клонирайте или изтеглете проекта
cd ParallelPatternMatching

# Възстановете зависимостите
dotnet restore

# Компилирайте проекта
dotnet build -c Release
```

## Употреба

### Стартиране на Приложението

```bash
dotnet run -c Release
```

### Опции в Менюто

**1. Бърз Тест (Малък Текст)**
- Демонстрира точно съвпадение на шаблон върху малък пример
- Показва позициите, където е намерен шаблонът
- Полезно за разбиране на поведението на алгоритмите

**2. Среден Тест (1 MB)**
- Генерира 1 милион случайни символа
- Извлича 12-символен шаблон
- Сравнява последователна срещу паралелна производителност

**3. Голям Тест (10 MB)**
- Генерира 10 милиона случайни символа
- Извлича 15-символен шаблон
- Стрес тест на паралелните имплементации

**4. Тест за Мащабируемост**
- Тества алгоритмите с 1, 2, 4 и 8 нишки
- Показва коефициенти на ускорение за всяка конфигурация
- Помага за идентифициране на оптималния брой нишки

**5. Собствен Тест**
- Въведете свой собствен текст и шаблон
- Използвайте `gen:N` за генериране на N случайни символа
- Задайте собствен брой нишки

## Примерен Изход

```
=== СРЕДЕН ТЕСТ (1 MB) ===

Текст: 1,000,000 символа
Шаблон: "ACGTACGTACGT" (12 символа)
Нишки: 8
────────────────────────────────────────────────────────────

KMP:
  Sequential:     8.523 ms
  Parallel:       1.856 ms
  Speedup:        4.59x
  Efficiency:     57.4%
  Matches:        976
  Verified:       ✓ OK

Boyer-Moore:
  Sequential:     5.234 ms
  Parallel:       1.425 ms
  Speedup:        3.67x
  Efficiency:     45.9%
  Matches:        976
  Verified:       ✓ OK

Aho-Corasick:
  Sequential:     7.891 ms
  Parallel:       1.723 ms
  Speedup:        4.58x
  Efficiency:     57.2%
  Matches:        976
  Verified:       ✓ OK
```

## Архитектура

### Структура на Проекта

```
ParallelPatternMatching/
├── Program.cs              # Основна имплементация
├── README.md              # Английска документация
├── README.bg.md           # Българска документация
└── ParallelPatternMatching.csproj
```

### Ключови Компоненти

**Модели за Данни**
- `SearchResult`: Капсулира резултати от алгоритми и метрики за производителност

**Класове на Алгоритми**
- `KMP`: Имплементация на Knuth-Morris-Pratt
- `BoyerMoore`: Имплементация на Boyer-Moore
- `AhoCorasick`: Имплементация на Aho-Corasick

**Помощни Класове**
- `TestDataGenerator`: Генериране на случаен текст и шаблони
- `Benchmark`: Рамка за тестване на производителността

### Стратегия на Паралелизация

Всички алгоритми използват **паралелизация базирана на парчета**:

1. **Разделяне на Текста**: Входният текст се разделя на парчета (по едно на нишка)
2. **Обработка на Припокриване**: Парчетата включват припокриващи се региони за улавяне на гранични съвпадения
3. **Локални Резултати**: Всяка нишка поддържа свой собствен списък с резултати
4. **Агрегиране**: Резултатите се обединяват и сортират след паралелното изпълнение
5. **Верификация**: Паралелните резултати се сравняват със sequential baseline

#### Изчисляване на Парчета

```csharp
int chunkSize = (n + threadCount - 1) / threadCount;
int start = threadId * chunkSize;
int end = Math.Min(start + chunkSize + patternLength - 1, n);
```

Припокриването от `patternLength - 1` гарантира, че няма пропуснати съвпадения на границите на парчетата.

## Характеристики на Производителността

### Очаквано Ускорение

На четириядрен процесор, типичните диапазони на ускорение са:
- **KMP**: 2.5x - 3.5x
- **Boyer-Moore**: 2.0x - 3.0x
- **Aho-Corasick**: 2.5x - 3.5x

Ефективността намалява с повече нишки поради:
- Overhead на синхронизация
- Ограничения на паметовата честотна лента
- Ефекти на кеша

### Кога Паралелизацията Помага

Паралелизацията е най-ефективна когато:
- Размер на текста > 100,000 символа
- Шаблонът е относително кратък (< 100 символа)
- Налични са множество CPU ядра
- Паметовата честотна лента е достатъчна

### Кога Последователната Версия е По-Добра

Използвайте последователни версии когато:
- Размер на текста < 10,000 символа
- Едноядрена среда
- Паметта е ограничена
- Overhead на създаването на нишки надхвърля ползите

## Сравнение на Алгоритмите

| Алгоритъм     | Предобработка | Най-добър | Среден случай | Най-лош случай | Памет    |
|---------------|---------------|-----------|---------------|----------------|----------|
| KMP           | O(m)          | O(n)      | O(n)          | O(n)           | O(m)     |
| Boyer-Moore   | O(m + σ)      | O(n/m)    | O(n)          | O(nm)          | O(m + σ) |
| Aho-Corasick  | O(Σm)         | O(n)      | O(n + z)      | O(n + z)       | O(Σm)    |

Където:
- n = дължина на текста
- m = дължина на шаблона
- σ = размер на азбуката
- Σm = сума от всички дължини на шаблони
- z = брой съвпадения

## Персонализация

### Промяна на Азбуката

Модифицирайте извикването на `TestDataGenerator.GenerateText`:

```csharp
// ДНК последователности (по подразбиране)
string text = TestDataGenerator.GenerateText(1000000, "ACGT");

// Двоична
string text = TestDataGenerator.GenerateText(1000000, "01");

// Малки букви
string text = TestDataGenerator.GenerateText(1000000, "абвгдежзийклмнопрстуфхцчшщъьюя");
```

### Добавяне на Нови Тестови Случаи

Разширете менюто в `Program.Main()`:

```csharp
case "6":
    МойПерсонализиранТест();
    break;
```

### Настройка на Броя Нишки

```csharp
// Използвайте всички налични ядра (по подразбиране)
var result = KMP.SearchParallel(text, pattern);

// Използвайте конкретен брой нишки
var result = KMP.SearchParallel(text, pattern, 4);
```

## Технически Бележки

### Безопасност на Нишките

Всички паралелни имплементации са thread-safe:
- Всяка нишка пише в свой собствен локален списък с резултати
- Няма споделено променливо състояние по време на фазата на търсене
- Финалното агрегиране се случва след като всички нишки приключат

### Съображения за Паметта

За големи текстове (> 100 MB):
- Обмислете стрийминг подходи
- Наблюдавайте използването на памет
- Настройте размерите на парчетата при нужда

### Платформени Разлики

Производителността може да варира на базата на:
- CPU архитектура (x86 срещу ARM)
- Брой ядра и хиперкоришане
- Размери на кеша
- Планировчик на операционната система

## Отстраняване на Проблеми

### Предупреждения при Компилация

Предупрежденията за nullable референции (CS8600, CS8618, и т.н.) не са критични и могат безопасно да бъдат игнорирани. Приложението функционира коректно въпреки тези предупреждения.

За да потиснете предупрежденията, добавете в `.csproj`:

```xml
<PropertyGroup>
  <Nullable>disable</Nullable>
</PropertyGroup>
```

### Проблеми с Производителността

Ако паралелната версия е по-бавна:
1. Увеличете размера на текста (overhead на паралелизацията може да доминира)
2. Проверете броя нишки (твърде много нишки могат да навредят на производителността)
3. Наблюдавайте използването на CPU (уверете се, че ядрата се използват)
4. Проверете Release компилация (флаг `-c Release`)

## Допринасяне

Потенциални подобрения:
- Добавяне на повече алгоритми (Rabin-Karp, Z-алгоритъм)
- Имплементиране на SIMD оптимизации
- Добавяне на GPU ускорение
- Поддръжка за Unicode/UTF-8
- Вход от файл
- Експорт на резултати в CSV/JSON

## Лиценз

Това е курсов проект за образователни цели.

## Референции

- Knuth, D. E.; Morris, J. H.; Pratt, V. R. (1977). "Fast pattern matching in strings"
- Boyer, R. S.; Moore, J. S. (1977). "A fast string searching algorithm"
- Aho, A. V.; Corasick, M. J. (1975). "Efficient string matching: an aid to bibliographic search"

## Автор

Курсов Проект - Паралелно Програмиране (2025)

---

## Бързо Ръководство

### Минимален Пример

```csharp
using ParallelPatternMatching;

// Създайте текст и шаблон
string text = "ABABDABACDABABCABAB";
string pattern = "ABAB";

// KMP търсене
var result = KMP.SearchSequential(text, pattern);
Console.WriteLine($"Намерени позиции: [{string.Join(", ", result.Positions)}]");
// Изход: Намерени позиции: [0, 10, 15]

// Паралелно търсене
var parallelResult = KMP.SearchParallel(text, pattern, 4);
Console.WriteLine($"Време: {parallelResult.TimeMs} ms");
```

### Работа с Множество Шаблони (Aho-Corasick)

```csharp
var ac = new AhoCorasick();
ac.AddPattern("ДНК");
ac.AddPattern("РНК");
ac.AddPattern("протеин");
ac.Build();

string text = "ДНК кодира РНК, който прави протеин";
var result = ac.SearchSequential(text);

foreach (int pos in result.Positions)
{
    Console.WriteLine($"Намерено на позиция: {pos}");
}
```

### Персонализиран Бенчмарк

```csharp
// Генерирайте голям тестов текст
string text = TestDataGenerator.GenerateText(5_000_000, "ACGT");
string pattern = "ACGTACGT";

// Пуснете бенчмарк с 8 нишки
Benchmark.Run(text, pattern, 8);
```

## Често Задавани Въпроси

**В: Защо паралелната версия е по-бавна на малки текстове?**

О: Overhead на създаването и управлението на нишки може да надвиши ползите за малки размери на входни данни. Паралелизацията е полезна обикновено за текстове > 100,000 символа.

**В: Колко нишки трябва да използвам?**

О: Започнете с броя на физическите ядра на вашия CPU. Повечето съвременни системи имат 4-8 ядра. Използвайте теста за мащабируемост за да намерите оптималния брой.

**В: Мога ли да търся Unicode текст?**

О: Да, алгоритмите работят с Unicode символи, но имайте предвид, че производителността може да варира за мултибайтови кодировки.

**В: Как да сравня с .NET вградените методи?**

О: Можете да добавите бенчмарк за `String.IndexOf()` или `String.Contains()` за сравнение:

```csharp
var sw = Stopwatch.StartNew();
int pos = text.IndexOf(pattern);
sw.Stop();
Console.WriteLine($"IndexOf: {sw.Elapsed.TotalMilliseconds} ms");
```

**В: Защо Aho-Corasick за един шаблон?**

О: Aho-Corasick е проектиран за множество шаблони, но е включен за пълнота и сравнение. За един шаблон, KMP или Boyer-Moore обикновено са по-ефективни.

## Допълнителни Ресурси

- [.NET Parallel Programming Guide](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/)
- [String Matching Algorithms - GeeksforGeeks](https://www.geeksforgeeks.org/algorithms-gq/pattern-searching/)
- [Introduction to Algorithms (CLRS)](https://mitpress.mit.edu/books/introduction-algorithms-third-edition)

## Поддръжка

За въпроси или проблеми относно този курсов проект, моля свържете се с преподавателя или използвайте университетските форуми.
